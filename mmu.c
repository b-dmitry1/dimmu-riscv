#include "riscv.h"

// Установка режима MMU и адреса каталога страниц
ui set_atp(riscv_t* cpu, ui value)
{
	cpu->mmu_on = 0;

	if ((value & SATP_MODE_ENABLE) == 0)
		return value;

	// ОС пытается включить MMU

	// В 32-битном режиме размер записи 4 байта, и в 4 КБ странице умещается 1024 записи.
	// Будет установлен режим sv32 - 2 уровня по 1024 записи,
	// это 10 + 10 + 12 = 32 бита, т.е., 4 ГБ адресуемого пространства

	// В 64-битном режиме размер записи 8 байт, и в 4 КБ странице умещается 512 записей.
	// ОС сначала попытается установить sv57 - 5 уровней, затем sv48 - 4 уровня,
	// затем sv39 - 3 уровня по 512 записей.
	// sv39 - это то, что нам нужно, это 9 + 9 + 9 + 12 = 39 бит, т.е., 512 ГБ
	// адресуемого пространства, вполне достаточно для всяких Питонов.
	// Чем меньше уровней, тем быстрее трансляция адресов, поэтому не будем позволять ОС
	// устанавливать любые режимы, кроме sv39 для riscv64.
	// Если нужны режимы sv48/sv57, сделайте их в файле riscv.h, они тоже работают:
	// Для Sv48:
	// SATP_MODE_ENABLE 0x9000000000000000llu
	// MMU_LEVELS 4
	// MMU_PAGE_MASK 0x7FFFFFFFFFllu
	// Для Sv57:
	// SATP_MODE_ENABLE 0xA000000000000000llu
	// MMU_LEVELS 5
	// MMU_PAGE_MASK 0xFFFFFFFFFFFFllu


	// Избавиться от всех режимов, кроме sv32 или sv39
	if ((value & SATP_MODE_MASK) != SATP_MODE_ENABLE)
		return 0;

	// Здесь можно сделать дополнительные проверки

	// Сохранить адрес главного каталога страниц
	cpu->atp = (ui*)&cpu->ram[(value & 0x3FFFFu) << 12];

	// Включить MMU
	cpu->mmu_on = 1;

	return value;
}

/* Функция преобразования адресов
 * cpu - ядро risc-v
 * virt - виртуальный адрес
 * res - физический адрес (результат)
 * test - битовая маска для проверки битов страницы (права доступа)
 * set - битовая маска для установки битов страницы (например, отметить, как модифицированную)
 * cause1 - код исключения по доступу к памяти
 * cause2 - код исключения page fault, когда страница не существует или нет прав доступа
 */ 
int virt2phys(riscv_t* cpu, ui* res, ui virt, ui test, ui set, ui cause1, ui cause2)
{
	ui pte;
	ui vpn[MMU_LEVELS];
	ui* table;
	ui addr;
	ui pagemask;
	int i;

	// Если не включен блок MMU, то виртуальный адрес всегда соответствует физическому
	*res = virt;
	if (!cpu->mmu_on)
		return 1;

	// Извлечь номера страниц для виртуального адреса
	// Каждая страница состоит из 1024 или 512 записей
	for (i = 0; i < MMU_LEVELS; i++)
		vpn[i] = (virt >> (12 + MMU_LEVEL_BITS * i)) & MMU_VPN_MASK;

	// В начале имеем дело с большими страницами по 4 МБ (sv32) или 1 ГБ (sv39)
	pagemask = MMU_PAGE_MASK;

	// Начать с главного каталога страниц
	table = cpu->atp;

	// Последовательно проверять уровни, начиная со старшего
	for (i = MMU_LEVELS - 1; i >= 0; i--)
	{
		// Получить запись из каталога
		pte = table[vpn[i]];
		// Извлечь физический адрес
		addr = (pte >> 10) << 12u;

		// Если не установлен флаг "valid", то сгенерировать исключение page fault
		if (!(pte & MMU_V))
		{
			if (cause2 != 0)
				trap(cpu, cause2, virt);
			return 0;
		}

		// Если хотя бы 1 из битов R, W, X установлен, то это указатель на страницу с данными
		if (pte & 0x0E)
		{
			// Проверить флаги разрешений страницы (например, нельзя выполнять код из страницы,
			// где не установлен бит X, и нельзя записывать в страницу, где нет бита W)
			if ((pte & test) != test)
			{
				if (cause2 != 0)
					trap(cpu, cause2, virt);
				return 0;
			}

			// Если это пользовательский режим, то проверить, имеет ли пользователь
			// право доступа к этой странице
			if (!cpu->s_mode && !(pte & MMU_USER))
			{
				if (cause1 != 0)
					trap(cpu, cause1, virt);
				return 0;
			}

			// Установить необходимые флаги в таблице. Здесь обычно страница помечается, как
			// accessed, т.е., к ней был доступ, либо dirty, если в неё была запись.
			// ОС таким образом сможет узнать, к каким сраницам обращалось приложение
			table[vpn[i]] |= set;

			// Старшие биты физического адреса берутся из каталога,
			// а младшие из запрошенного виртуального адреса.
			// Здесь страница может быть размером 4 КБ или 4 МБ для 32-битного процессора
			// и 4 КБ или 2 МБ или 1 ГБ для 64-битного процессора, в зависимости от кол-ва уровней
			*res = addr + (virt & pagemask);

			return 1;
		}

		// Это указатель на каталог страниц нижнего уровня
		// Получить физический адрес каталога
		addr -= RAM_START;
		if (addr >= RAM_SIZE)
		{
			if (cause1 != 0)
				trap(cpu, cause1, virt);
			return 0;
		}
		table = (ui*)&cpu->ram[addr];

		// Уменьшить размер страницы
		pagemask >>= MMU_LEVEL_BITS;
	}

	// Ошибка в каталогах, сгенерировать исключение доступа
	if (cause1 != 0)
		trap(cpu, cause1, virt);

	return 0;
}
